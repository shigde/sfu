package rtp

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/interceptor/pkg/stats"
	"github.com/pion/webrtc/v3"
	"github.com/shigde/sfu/internal/static"
	"golang.org/x/exp/slog"
)

type Engine struct {
	config webrtc.Configuration
}

func NewEngine(rtpConfig *RtpConfig) (*Engine, error) {
	config := rtpConfig.getWebrtcConf()
	return &Engine{
		config: config,
	}, nil
}

func (e *Engine) createApi(apiOptions ...engineApiOption) (*engineApi, error) {
	api := &engineApi{}

	for _, o := range apiOptions {
		o(api)
	}

	m := &webrtc.MediaEngine{}
	if err := m.RegisterDefaultCodecs(); err != nil {
		return nil, fmt.Errorf("register  default codecs: %w ", err)
	}

	var statsInterceptorFactory *stats.InterceptorFactory
	var err error
	if api.onStatsGetter != nil {
		if statsInterceptorFactory, err = stats.NewInterceptor(); err != nil {
			return nil, fmt.Errorf("create stats interceptor factory: %w", err)
		}
		statsInterceptorFactory.OnNewPeerConnection(func(_ string, getter stats.Getter) {
			api.onStatsGetter(getter)
		})
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	i := &interceptor.Registry{}

	// Use the default set of Interceptors
	if err := webrtc.RegisterDefaultInterceptors(m, i); err != nil {
		return nil, fmt.Errorf("register default interceptors: %w ", err)
	}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		return nil, fmt.Errorf("create interval Pli factory: %w ", err)
	}
	i.Add(intervalPliFactory)
	if statsInterceptorFactory != nil {
		i.Add(statsInterceptorFactory)
	}

	api.API = webrtc.NewAPI(webrtc.WithMediaEngine(m), webrtc.WithInterceptorRegistry(i))
	return api, nil
}

func (e *Engine) EstablishEndpoint(ctx context.Context, sessionCtx context.Context, sessionId uuid.UUID, liveStream uuid.UUID, offer webrtc.SessionDescription, endpointType EndpointType, options ...EndpointOption) (*Endpoint, error) {
	return establishEndpoint(ctx, sessionCtx, e, sessionId, liveStream, offer, endpointType, options...)
}

func (e *Engine) OfferEndpoint(ctx context.Context, sessionCtx context.Context, sessionId uuid.UUID, liveStream uuid.UUID, endpointType EndpointType, options ...EndpointOption) (*Endpoint, error) {
	return offerEndpoint(ctx, sessionCtx, e, sessionId, liveStream, endpointType, options...)
}

func creatDC(pc *webrtc.PeerConnection, onChannel func(dc *webrtc.DataChannel)) error {
	ordered := false
	maxRetransmits := uint16(0)

	options := &webrtc.DataChannelInit{
		Ordered:        &ordered,
		MaxRetransmits: &maxRetransmits,
	}

	// Create a datachannel with label 'data'
	dc, err := pc.CreateDataChannel("data", options)
	if err != nil {
		return fmt.Errorf("creating data channel: %w", err)
	}
	onChannel(dc)
	return nil
}

// Deprecated API

// NewStaticMediaSenderEndpoint can be used to send static streams from file in a lobby.
// Deprecated: Because the Endpoint API is getting simpler
func (e *Engine) NewStaticMediaSenderEndpoint(media *static.MediaFile) (*Endpoint, error) {
	stateHandler := newMediaStateEventHandler()
	api, err := e.createApi()
	if err != nil {
		return nil, fmt.Errorf("creating api: %w", err)
	}
	peerConnection, err := api.NewPeerConnection(e.config)
	if err != nil {
		return nil, fmt.Errorf("create receiver peer connection: %w ", err)
	}

	iceConnectedCtx, iceConnectedCtxCancel := context.WithCancel(context.Background())

	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
		slog.Debug("rtp.engine: connection State has changed", "state", connectionState.String())
		if connectionState == webrtc.ICEConnectionStateConnected {
			iceConnectedCtxCancel()
		}
	})

	rtpVideoSender, err := peerConnection.AddTrack(media.VideoTrack)
	if err != nil {
		return nil, fmt.Errorf("add video track to peer connection: %w ", err)
	}
	media.PlayVideo(iceConnectedCtx, rtpVideoSender)

	rtpAudioSender, err := peerConnection.AddTrack(media.AudioTrack)
	if err != nil {
		return nil, fmt.Errorf("add audio track to peer connection: %w ", err)
	}
	media.PlayAudio(iceConnectedCtx, rtpAudioSender)

	err = creatDC(peerConnection, stateHandler.OnChannel)

	if err != nil {
		return nil, fmt.Errorf("creating data channel: %w", err)
	}

	offer, err := peerConnection.CreateOffer(nil)
	if err != nil {
		return nil, fmt.Errorf("creating offer: %w", err)
	}

	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	if err = peerConnection.SetLocalDescription(offer); err != nil {
		return nil, err
	}

	return &Endpoint{peerConnection: peerConnection, gatherComplete: gatherComplete}, nil
}

// NewSignalConnection can be used to listen on lobby events.
// Deprecated: Because the Endpoint API is getting simpler
func (e *Engine) NewSignalConnection(ctx context.Context, handler StateEventHandler) (*Connection, error) {
	api, err := e.createApi()
	if err != nil {
		return nil, fmt.Errorf("creating api: %w", err)
	}
	peerConnection, err := api.NewPeerConnection(e.config)
	if err != nil {
		return nil, fmt.Errorf("create receiver peer connection: %w ", err)
	}

	_, iceConnectedCtxCancel := context.WithCancel(ctx)

	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
		// fmt.Printf("Connection State has changed %s \n", connectionState.String())
		if connectionState == webrtc.ICEConnectionStateConnected {
			iceConnectedCtxCancel()
		}
	})

	err = creatDC(peerConnection, handler.OnChannel)

	if err != nil {
		return nil, fmt.Errorf("creating data channel: %w", err)
	}

	offer, err := peerConnection.CreateOffer(nil)
	if err != nil {
		return nil, fmt.Errorf("creating offer: %w", err)
	}

	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	if err = peerConnection.SetLocalDescription(offer); err != nil {
		return nil, err
	}

	return &Connection{PeerConnection: peerConnection, GatherComplete: gatherComplete}, nil
}

// NewReceiverConnection
// Deprecated: Because the Endpoint API is getting simpler
func (e *Engine) NewReceiverConnection(ctx context.Context, offer webrtc.SessionDescription, handler StateEventHandler, rtmpEndpoint string) (*Connection, error) {
	api, err := e.createApi()
	if err != nil {
		return nil, fmt.Errorf("creating api: %w", err)
	}
	peerConnection, err := api.NewPeerConnection(e.config)
	if err != nil {
		return nil, fmt.Errorf("create receiver peer connection: %w ", err)
	}

	peerConnection.OnDataChannel(func(d *webrtc.DataChannel) {
		slog.Debug("rtp.engine: receiverEndpoint new DataChannel", "label", d.Label(), "id", d.ID())
		handler.OnChannel(d)
	})
	// Allow us to receive 1 audio track, and 1 video track
	if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio); err != nil {
		slog.Error("rtp.engine: .addTransceiverFromKind audio", "err", err)
	} else if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo); err != nil {
		slog.Error("rtp.engine: .addTransceiverFromKind video", "err", err)
	}

	go func(ctx context.Context, pc *webrtc.PeerConnection, rtmp string) {
		rtmpListener(ctx, pc, rtmp)
	}(ctx, peerConnection, rtmpEndpoint)

	if err := peerConnection.SetRemoteDescription(offer); err != nil {
		return nil, err
	}

	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)
	answer, err := peerConnection.CreateAnswer(nil)
	if err != nil {
		return nil, err
	}

	if err = peerConnection.SetLocalDescription(answer); err != nil {
		return nil, err
	}

	return &Connection{
		PeerConnection: peerConnection,
		GatherComplete: gatherComplete,
	}, nil
}
